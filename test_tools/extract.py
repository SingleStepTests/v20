# extract.py
#
# Given a specified JSON or gzipped JZON test file, this utility will extract
# a specific test specified either by decimal index or hexadecimal hash 
# (test_hash key must have been created by the addhash.py tool or otherwise 
# generated by a test suite)
#
# The test, if found, will be exported to the path specified by the third 
# argument.

import json
import sys
import re
import gzip

# Helper function to condense a list into its string representation
def list_to_str(lst):
    def format_value(value):
        if isinstance(value, str):
            return f'"{value}"'
        return str(value)

    return '[' + ', '.join(format_value(value) for value in lst) + ']'

def condense(test_data):
    """Condenses JSON data for specific fields"""

    # Iterate over each object in the test data array
    for item in test_data:
        # Convert the 'bytes' field to a string
        if "bytes" in item:
            item["bytes"] = list_to_str(item["bytes"])

        # Convert each internal list of 'ram' field to a string
        if "ram" in item["initial"]:
            item["initial"]["ram"] = [list_to_str(sublist) for sublist in item["initial"]["ram"]]
        
        if "ram" in item["final"]:
            item["final"]["ram"] = [list_to_str(sublist) for sublist in item["final"]["ram"]]
        
        if "queue" in item["initial"]:
            item["initial"]["queue"] = list_to_str(item["initial"]["queue"])

        if "queue" in item["final"]:
            item["final"]["queue"] = list_to_str(item["final"]["queue"])

        if "cycles" in item:
            for sublist in item["cycles"]:
                try:
                    sublist[1] = int(sublist[1])
                except (ValueError, IndexError, TypeError):
                    pass  # If conversion fails or there's no second element, we skip and leave it unchanged

            item["cycles"] = [list_to_str(sublist) for sublist in item["cycles"]]

    def hint_encoder(obj, current_item):
        # If it matches the condense format, it's already a string; return it
        if isinstance(obj, str) and obj.startswith('[') and obj.endswith(']'):
            return obj
        raise TypeError

    results = []
    for current_item in test_data:
        result_str = json.dumps(current_item, default=lambda obj: hint_encoder(obj, current_item), indent=4)
        
        # Handle 'bytes','ram', and 'cycles' fields
        if "bytes" in current_item:
            result_str = result_str.replace(f'"{current_item["bytes"]}"', current_item["bytes"])
        if "ram" in current_item["initial"]:
            for sublist_str in current_item["initial"]["ram"]:
                result_str = result_str.replace(f'"{sublist_str}"', sublist_str)
        if "ram" in current_item["final"]:
            for sublist_str in current_item["final"]["ram"]:
                result_str = result_str.replace(f'"{sublist_str}"', sublist_str)    
        if "queue" in current_item["initial"]:
            result_str = result_str.replace(f'"{current_item["initial"]["queue"]}"', current_item["initial"]["queue"])
        if "queue" in current_item["final"]:
            result_str = result_str.replace(f'"{current_item["final"]["queue"]}"', current_item["final"]["queue"])
        if "cycles" in current_item:
            for sublist_str in current_item["cycles"]:
                #print(f"sublist str is: {sublist_str}")

                replace_str = sublist_str.replace('"', '\\"')
                #print(f"replace str is {replace_str}")
                result_str = result_str.replace(f'"{replace_str}"', sublist_str)        

        results.append(result_str)
        
    return "[\n" + ",\n".join(results) + "\n]"


def is_test_index(value):
    """Check if the given value is a test index based on its format."""
    return re.match("^\d+$", value)

def extract_test_from_file(file_path, value):
    """Extract a test from the JSON or gzipped JSON file based on the test index or test_hash."""

    data = None

    # Check if the file is gzipped and load the content accordingly
    if file_path.endswith('.gz'):
        with gzip.open(file_path, 'rt', encoding='utf-8') as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError:
                print("The provided file is not a valid gzipped JSON.")
    else:
        with open(file_path, 'r') as f:
            try:
                data = json.load(f)
            except json.JSONDecodeError:
                print("The provided file is not a valid JSON.")

    if data and isinstance(data, list):
        if is_test_index(value):  # If the provided value is an index
            idx = int(value)
            if 0 <= idx < len(data):
                return data[idx]
            else:
                print(f"Test index {idx} is out of range for the provided file.")
        else:  # If the provided value is a test_hash
            for obj in data:
                if obj.get('hash') == value:
                    return obj
            print(f"No test found with hash: {value} in the provided file.")

    return None

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: extract.py <test_path> <test_index_or_hash> <output_file>")
        sys.exit(1)

    test_path = sys.argv[1]
    test_value = sys.argv[2]
    output_file = sys.argv[3]

    # Extract the test based on index or hash
    test_obj = extract_test_from_file(test_path, test_value)
    
    if test_obj:
        with open(output_file, 'w') as f_out:
            json_str = json.dumps(test_obj, indent=4)
            json_arr = "[" + json_str + "]"
            final_json = json.loads(json_arr)
            final_string = condense(final_json)
            f_out.write(final_string)

        print(f"Test {test_value} extracted and saved to {output_file}.")